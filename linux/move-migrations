#!/bin/bash -eu

# A script for moving Django migrations files around, from another git branch.
#
# Given a branch name and an app name, this script will figure out which
# migration files have been added, and re-arrange the migration files
# so they come after migration files added in the other branch.

if ! [ $# -eq 2 ] || [ -z "$1" ] || [ -z "$2" ]; then
    echo "Usage: move-migrations <from_branch> <app_name>" 1>&2
    exit 1
fi

# Set up and validate the arguments.
branch_name="$1"
app_name="${2%/}"

if [[ ! "$app_name" =~ ^[a-zA-Z][a-zA-Z_0-9]*$ ]]; then
    echo "Invalid app name: $app_name" 1>&2
    exit 1
fi

if ! git rev-parse --verify "$branch_name" > /dev/null; then
    echo "Invalid branch name: $branch_name" 1>&2
    exit 1
fi

cd "$app_name/migrations"

# A command for finding migrations added in this branch
added_migrations="git diff --name-only --diff-filter=A --relative $branch_name --"
moved_files=()

# A function for finding the last migration file.
find_last_migration() {
    local last_filename
    local last_file_found=0

    if [ "${#moved_files[@]}" -gt 0 ]; then
        # We have already moved at least one file, so return the last one
        # we moved. We don't have to search for any more files.
        echo "${moved_files[-1]}"
        return 0
    fi

    # We haven't moved any files yet, so find the last file which isn't ours.
    for last_filename in $((git ls-files --with-tree origin/dev && /bin/ls -1) | sort -nur); do
        if ! [[ "$last_filename" == *.py ]]; then
            # Skip files which aren't Python files.
            continue
        fi

        if [ "$last_filename" == '__init__.py' ]; then
            # Skip __init__.py
            continue
        fi

        # If this file isn't ours, then it's the last file.
        if ! [[ $($added_migrations "$last_filename") ]]; then
            last_file_found=1
            break
        fi
    done

    if ! [ $last_file_found -eq 1 ]; then
        echo "Failed to find the last migration file! Stopping here." 1>&2
        exit 1
    fi

    echo "$last_filename"
}

# Try to find the last migration straight away, so we can fail early.
find_last_migration > /dev/null

for filename in $($added_migrations .); do
    end_filename=$(find_last_migration)
    end_migration_name="${end_filename::-3}"

    # Extract the number and the suffix.
    migration_number=$(echo "$end_filename" | grep -o '^[0-9]\+')
    migration_suffix=$(echo "$filename" | sed 's/^[0-9]\+//')

    # Increment it.
    migration_number=$(printf '%04d' $(expr $migration_number + 1))

    # Build the new filename.
    new_filename="$migration_number$migration_suffix"

    if [ "$filename" == "$new_filename" ]; then
        echo 'There is nothing to move.' 1>&2
        exit 0
    fi

    echo "Moving migration $filename" 1>&2

    # Move the migration forward now.
    mv "$filename" "$new_filename"

    # Find where the dependency lines start and end, to limit sed to
    # editing only those lines.
    start_line=$(grep -n 'dependencies *=' "$new_filename" | head -1 | cut -d : -f 1)
    end_offset=$(tail -n "+$start_line" "$new_filename" | grep -n '\]' | head -1 | cut -d : -f 1)
    end_line=$(expr $start_line + $end_offset)

    # Fix the dependencies.
    sed -i "${start_line},${end_line}s/('$app_name', '[^']\+')/('$app_name', '$end_migration_name')/" "$new_filename"

    # Add this file to the array of moved files, so it will become the new
    # 'last' file.
    moved_files+=("$new_filename")
done

# Now add all of the changes.
git add -A .

echo 'Migrations moved. Check git diff --cached.'
echo 'Commit the changes if you are happy with them.'
